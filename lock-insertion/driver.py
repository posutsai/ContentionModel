#!/usr/local/bin/python3
import sys
import yaml
import itertools
import argparse
import subprocess
import os
import pathlib
import shutil

# Functions and variables for optimize_lock mode.

def get_combination(yaml_path):
    with open(yaml_path, "r") as stream:
        meta_data = list(yaml.load_all(stream, Loader=yaml.FullLoader))
    combs = []
    for m in meta_data[0]["LockEntity"]:
        if "lock_combination" in m.keys():
            if "PTHREADMTX" in m["lock_combination"]:
                combs.append([*m["lock_combination"]])
            else:
                combs.append([*m["lock_combination"], "PTHREADMTX"])
        else:
            combs.append(["PTHREADMTX"])
    # combs = [ tuple(m["lock_combination"]) if "lock_combination" in m.keys() else ("PTHREADMTX", ) for m in meta_data[0]["LockEntity"]]
    for comb in itertools.product(*combs):
        current_iter = []
        for i, c in enumerate(comb):
            current_iter.append("#define DYLINX_LOCK_MACRO_{} dylinx_{}lock_t".format(i, c.lower()))
        yield '\n'.join(current_iter)
    print("All combination is iterated !")


def brute_force(args):
    header_start = "#ifndef __DYLINX_ITERATE_LOCK_COMB__\n#define __DYLINX_ITERATE_LOCK_COMB__"
    header_end = "#endif // __DYLINX_ITERATE_LOCK_COMB__"
    # Generate dylinx-insertion.yaml
    with subprocess.Popen(args=["dylinx", args.compiler_commands], stdout=subprocess.PIPE) as proc:
        out = proc.stdout.read().decode("utf-8").split('\n')[0]
        print(out)
    for comb in get_combination("{}/dylinx-insertion.yaml".format(args.output_dir)):
        with open("{}/dylinx-runtime-config.h".format(os.environ["DYLINX_GLUE_SRC"]), "w") as rt_config:
            rt_config.write( "{}\n\n{}\n\n{}".format(header_start, comb, header_end))
        os.environ["C_INCLUDE_PATH"] = os.environ["DYLINX_GLUE_SRC"]
        with subprocess.Popen(args=args.build_command.split(' '), stdout=subprocess.PIPE) as proc:
            out = proc.stdout.read().decode("utf-8")
        print(out)
        if args.clear_command != None:
            with subprocess.Popen(args=args.clear_command.split(' '), stdout=subprocess.PIPE) as proc:
                out = proc.stdout.read().decode("utf-8")
            print(out)

def optimize_locks(args):
    brute_force(args)

def revert(args):
    with open("{}/dylinx-insertion.yaml".format(args.output_dir), "r") as f:
        for f in list(yaml.load_all(f, Loader=yaml.FullLoader))[0]["AlteredFiles"]:
            p = pathlib.PurePath(f)
            shutil.copyfile(str(p.parent) + "/.dylinx/" + p.name, str(p))
            shutil.rmtree(str(p.parent) + "/.dylinx")
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-m",
        "--mode",
        type=str,
        choices=["reverse", "optimize_locks"],
        required=True,
        help="Configuring the operating mode."
    )
    parser.add_argument(
        "-o",
        "--output_dir",
        type=str,
        default=os.getcwd(),
        help="Configuring output yaml file path after Dylinx analyzes codebase."
    )
    parser.add_argument(
        "-cc",
        "--compiler_commands",
        default=None,
        help="The path of compiler_commands.json which is generated by tool depending on codebase."
    )
    parser.add_argument(
        "-bc",
        "--build_command",
        default=None,
        help="The command to rebuild the whole codebase after replacing altered files."
    )
    parser.add_argument(
        "-cl",
        "--clear_command",
        default=None,
    )
    args = parser.parse_args()
    if args.mode == "optimize_locks":
        optimize_locks(args)
    if args.mode == "reverse":
        revert(args)
